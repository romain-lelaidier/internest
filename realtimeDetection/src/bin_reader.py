"""
Binary audio file reader for ESP32 UDP audio packets.

Reads PCM 16-bit, 48kHz mono audio from .bin files generated by the Raspberry Pi
that receives UDP packets from ESP32 devices.

File naming convention: esp{id}_{timestamp}.bin
Example: esp1_1706620800.bin
"""

import re
import struct
from pathlib import Path
from dataclasses import dataclass
from typing import Optional, Generator
import numpy as np


@dataclass
class BinFileInfo:
    """Metadata extracted from a .bin audio file."""
    path: Path
    mac_address: str  # MAC address of the ESP
    timestamp: int  # Unix timestamp
    size_bytes: int
    duration_seconds: float
    sample_count: int


class BinAudioReader:
    """
    Reader for binary PCM audio files from ESP32 devices.

    Format: PCM 16-bit signed, 44.1kHz, mono
    File naming: {mac}_{unix_timestamp}.bin (e.g., 1c:db:d4:34:5c:04_1353637748.bin)
    ESP ID is extracted from last byte of MAC address.
    """

    SAMPLE_RATE = 44100  # 44.1kHz from ESP32
    BYTES_PER_SAMPLE = 2  # 16-bit = 2 bytes
    CHANNELS = 1  # mono

    # Regex to parse filename: {mac}_{timestamp}.bin
    # e.g., 1c:db:d4:34:5c:04_1353637748.bin (last byte of MAC = ESP ID)
    FILENAME_PATTERN = re.compile(r'^([0-9a-fA-F:]+)_(\d+)\.bin$')

    def __init__(self, sample_rate: int = 44100):
        self.sample_rate = sample_rate

    def parse_filename(self, path: Path) -> Optional[tuple[str, int]]:
        """
        Parse MAC address and timestamp from filename.

        Filename format: {mac}_{timestamp}.bin
        e.g., 1c:db:d4:34:5c:04_1353637748.bin

        Args:
            path: Path to .bin file

        Returns:
            Tuple of (mac_address, timestamp) or None if filename doesn't match pattern
        """
        match = self.FILENAME_PATTERN.match(path.name)
        if match:
            mac_address = match.group(1)
            timestamp = int(match.group(2))
            return mac_address, timestamp
        return None

    def get_file_info(self, path: Path) -> Optional[BinFileInfo]:
        """
        Get metadata about a .bin audio file.

        Args:
            path: Path to .bin file

        Returns:
            BinFileInfo with file metadata, or None if file doesn't match expected format
        """
        path = Path(path)

        if not path.exists():
            return None

        parsed = self.parse_filename(path)
        if parsed is None:
            return None

        mac_address, timestamp = parsed
        size_bytes = path.stat().st_size
        sample_count = size_bytes // self.BYTES_PER_SAMPLE
        duration_seconds = sample_count / self.sample_rate

        return BinFileInfo(
            path=path,
            mac_address=mac_address,
            timestamp=timestamp,
            size_bytes=size_bytes,
            duration_seconds=duration_seconds,
            sample_count=sample_count
        )

    def read_file(self, path: Path) -> np.ndarray:
        """
        Read entire .bin file as numpy array.

        Args:
            path: Path to .bin file

        Returns:
            Numpy array of float32 audio samples normalized to [-1.0, 1.0]
        """
        path = Path(path)

        with open(path, 'rb') as f:
            raw_data = f.read()

        # Unpack 16-bit signed integers (little-endian)
        sample_count = len(raw_data) // self.BYTES_PER_SAMPLE
        samples = struct.unpack(f'<{sample_count}h', raw_data[:sample_count * self.BYTES_PER_SAMPLE])

        # Convert to float32 normalized to [-1.0, 1.0]
        audio = np.array(samples, dtype=np.float32) / 32768.0

        return audio

    def read_file_streaming(
        self,
        path: Path,
        chunk_samples: int = 48000
    ) -> Generator[np.ndarray, None, None]:
        """
        Read .bin file in chunks (streaming mode).

        Args:
            path: Path to .bin file
            chunk_samples: Number of samples per chunk (default: 1 second at 48kHz)

        Yields:
            Numpy arrays of float32 audio samples
        """
        path = Path(path)
        chunk_bytes = chunk_samples * self.BYTES_PER_SAMPLE

        with open(path, 'rb') as f:
            while True:
                raw_data = f.read(chunk_bytes)
                if not raw_data:
                    break

                sample_count = len(raw_data) // self.BYTES_PER_SAMPLE
                if sample_count == 0:
                    break

                samples = struct.unpack(
                    f'<{sample_count}h',
                    raw_data[:sample_count * self.BYTES_PER_SAMPLE]
                )

                audio = np.array(samples, dtype=np.float32) / 32768.0
                yield audio

    def read_partial(
        self,
        path: Path,
        offset_samples: int = 0,
        num_samples: Optional[int] = None
    ) -> np.ndarray:
        """
        Read a portion of a .bin file.

        Args:
            path: Path to .bin file
            offset_samples: Starting sample offset
            num_samples: Number of samples to read (None = read to end)

        Returns:
            Numpy array of float32 audio samples
        """
        path = Path(path)
        offset_bytes = offset_samples * self.BYTES_PER_SAMPLE

        with open(path, 'rb') as f:
            f.seek(offset_bytes)

            if num_samples is not None:
                raw_data = f.read(num_samples * self.BYTES_PER_SAMPLE)
            else:
                raw_data = f.read()

        sample_count = len(raw_data) // self.BYTES_PER_SAMPLE
        if sample_count == 0:
            return np.array([], dtype=np.float32)

        samples = struct.unpack(
            f'<{sample_count}h',
            raw_data[:sample_count * self.BYTES_PER_SAMPLE]
        )

        return np.array(samples, dtype=np.float32) / 32768.0


def validate_bin_file(path: Path) -> tuple[bool, str]:
    """
    Validate that a file is a valid ESP audio .bin file.

    Args:
        path: Path to file to validate

    Returns:
        Tuple of (is_valid, message)
    """
    reader = BinAudioReader()

    path = Path(path)
    if not path.exists():
        return False, f"File does not exist: {path}"

    if path.suffix.lower() != '.bin':
        return False, f"Not a .bin file: {path}"

    parsed = reader.parse_filename(path)
    if parsed is None:
        return False, f"Filename doesn't match pattern {{mac}}_{{timestamp}}.bin: {path.name}"

    esp_id, timestamp = parsed

    size = path.stat().st_size
    if size == 0:
        return False, "File is empty"

    if size % 2 != 0:
        return False, f"File size ({size} bytes) is not a multiple of 2 (expected 16-bit samples)"

    return True, f"Valid: ESP{esp_id}, timestamp={timestamp}, {size//2} samples"
